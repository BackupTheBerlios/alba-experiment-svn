diff -Nrup config.h.in config.h.in
--- config.h.in	2006-04-09 18:52:37.000000000 +0800
+++ config.h.in	2006-06-20 11:29:26.639795000 +0800
@@ -24,7 +24,7 @@
    running kernel (if there are no configured kernel sources). */
 #undef GLIBTOP_LINUX_VERSION_CODE
 
-/* Solaris release code (eg. 251 for Solaris 2.5.1). */
+/* Solaris release code (eg. 20501 for Solaris 2.5.1). */
 #undef GLIBTOP_SOLARIS_RELEASE
 
 /* Define the location where the catalogs will be installed */
diff -Nrup configure.in configure.in
--- configure.in	2006-04-09 18:50:54.000000000 +0800
+++ configure.in	2006-06-29 12:37:30.647339000 +0800
@@ -164,6 +164,15 @@ dnl AIX
 AC_CHECK_LIB(perfstat, vmgetinfo,
     AC_DEFINE(HAVE_VMGETINFO, 1,
         [Define to 1 if you have the 'vmgetinfo' function in libperfstat]))
+	
+dnl Solaris msgfmt does not support the -c option so blank it.
+GMSGFMT_CHECKOPT=-c
+case "$host_os" in
+	solaris*)
+	GMSGFMT_CHECKOPT= ;;
+	*) GMSGFMT_CHECKOPT=-c ;;
+esac
+AC_SUBST(GMSGFMT_CHECKOPT)
 
 dnl Solaris
 case "$host_os" in
@@ -171,9 +180,10 @@ case "$host_os" in
      AC_CHECK_LIB(kstat, kstat_open)
      AC_CHECK_FUNCS(getloadavg swapctl)
      AC_CHECK_HEADERS(procfs.h sys/procfs.h, break)
-
-
+     
     dnl Some versions of Solaris require -lelf for -lkvm
+    case $host_os in
+    solaris[[8-9]] | solaris2.[[0-9]].*)
     AC_CHECK_LIB(kvm, kvm_open,[
       LIBS="-lkvm $LIBS"
     ],[AC_MSG_CHECKING(for kvm_open in -lkvm with -lelf)
@@ -192,6 +202,8 @@ case "$host_os" in
        fi
     ])
      ;;
+     esac
+     ;;
 esac
 
 dnl For DEC OSF1
diff -Nrup include/glibtop/error.h include/glibtop/error.h
--- include/glibtop/error.h	2005-02-15 18:14:59.000000000 +0800
+++ include/glibtop/error.h	2006-06-26 18:37:05.268278000 +0800
@@ -33,20 +33,20 @@
 
 G_BEGIN_DECLS
 
-void glibtop_error_vr (glibtop *server, const char *format, va_list args) G_GNUC_INTERNAL G_GNUC_NORETURN;
-void glibtop_warn_vr (glibtop *server, const char *format, va_list args) G_GNUC_INTERNAL;
-void glibtop_error_io_vr (glibtop *server, const char *format, int, va_list args) G_GNUC_INTERNAL G_GNUC_NORETURN;
-void glibtop_warn_io_vr (glibtop *server, const char *format, int, va_list args) G_GNUC_INTERNAL;
-
-void glibtop_error_r (glibtop *server, const char *format, ...) G_GNUC_INTERNAL G_GNUC_PRINTF(2, 3) G_GNUC_NORETURN;
-void glibtop_warn_r (glibtop *server, const char *format, ...) G_GNUC_INTERNAL G_GNUC_PRINTF(2, 3);
-void glibtop_error_io_r (glibtop *server, const char *format, ...) G_GNUC_INTERNAL G_GNUC_PRINTF(2, 3) G_GNUC_NORETURN;
-void glibtop_warn_io_r (glibtop *server, const char *format, ...) G_GNUC_INTERNAL G_GNUC_PRINTF(2, 3);
-
-void glibtop_error (const char *format, ...) G_GNUC_INTERNAL G_GNUC_PRINTF(1, 2) G_GNUC_NORETURN;
-void glibtop_warn (const char *format, ...) G_GNUC_INTERNAL G_GNUC_PRINTF(1, 2);
-void glibtop_error_io (const char *format, ...) G_GNUC_INTERNAL G_GNUC_PRINTF(1, 2) G_GNUC_NORETURN;
-void glibtop_warn_io (const char *format, ...) G_GNUC_INTERNAL G_GNUC_PRINTF(1, 2);
+G_GNUC_INTERNAL void glibtop_error_vr (glibtop *server, const char *format, va_list args)  G_GNUC_NORETURN;
+G_GNUC_INTERNAL void glibtop_warn_vr (glibtop *server, const char *format, va_list args) ;
+G_GNUC_INTERNAL void glibtop_error_io_vr (glibtop *server, const char *format, int, va_list args)  G_GNUC_NORETURN;
+G_GNUC_INTERNAL void glibtop_warn_io_vr (glibtop *server, const char *format, int, va_list args) ;
+
+G_GNUC_INTERNAL void glibtop_error_r (glibtop *server, const char *format, ...)  G_GNUC_PRINTF(2, 3) G_GNUC_NORETURN;
+G_GNUC_INTERNAL void glibtop_warn_r (glibtop *server, const char *format, ...)  G_GNUC_PRINTF(2, 3);
+G_GNUC_INTERNAL void glibtop_error_io_r (glibtop *server, const char *format, ...)  G_GNUC_PRINTF(2, 3) G_GNUC_NORETURN;
+G_GNUC_INTERNAL void glibtop_warn_io_r (glibtop *server, const char *format, ...)  G_GNUC_PRINTF(2, 3);
+
+G_GNUC_INTERNAL void glibtop_error (const char *format, ...)  G_GNUC_PRINTF(1, 2) G_GNUC_NORETURN;
+G_GNUC_INTERNAL void glibtop_warn (const char *format, ...)  G_GNUC_PRINTF(1, 2);
+G_GNUC_INTERNAL void glibtop_error_io (const char *format, ...)  G_GNUC_PRINTF(1, 2) G_GNUC_NORETURN;
+G_GNUC_INTERNAL void glibtop_warn_io (const char *format, ...)  G_GNUC_PRINTF(1, 2);
 
 G_END_DECLS
 
diff -Nrup include/glibtop/procmap.h include/glibtop/procmap.h
--- include/glibtop/procmap.h	2005-12-10 00:15:44.000000000 +0800
+++ include/glibtop/procmap.h	2006-07-05 16:38:49.648816000 +0800
@@ -60,6 +60,7 @@ G_BEGIN_DECLS
 #define GLIBTOP_MAP_PERM_EXECUTE	4
 #define GLIBTOP_MAP_PERM_SHARED		8
 #define GLIBTOP_MAP_PERM_PRIVATE	16
+#define GLIBTOP_MAP_PERM_SHAREDMEMORY	32
 
 typedef struct _glibtop_map_entry	glibtop_map_entry;
 
diff -Nrup include/glibtop/procmem.h include/glibtop/procmem.h
--- include/glibtop/procmem.h	2005-06-07 17:54:43.000000000 +0800
+++ include/glibtop/procmem.h	2006-05-29 11:56:43.561415000 +0800
@@ -53,6 +53,7 @@ struct _glibtop_proc_mem
 		rss,		/* resident set size */
 		rss_rlim;	/* current limit (in bytes) of the rss
 				 * of the process; usually 2,147,483,647 */
+	guint	load;		/* cpu load for process */
 };
 
 void glibtop_get_proc_mem(glibtop_proc_mem *buf, pid_t pid);
diff -Nrup libgtop-sysdeps.m4 libgtop-sysdeps.m4
--- libgtop-sysdeps.m4	2006-04-09 18:23:03.000000000 +0800
+++ libgtop-sysdeps.m4	2006-06-20 11:53:26.516762000 +0800
@@ -255,16 +255,16 @@ main (void)
 	  AC_MSG_RESULT($os_version_code)
 	  ;;
 	solaris*)
-	  os_major_version=`uname -r | sed 's/\([[0-9]]*\).\([[0-9]]\)\.*\([[0-9]]*\)/\1/'`
-	  os_minor_version=`uname -r | sed 's/\([[0-9]]*\).\([[0-9]]\)\.*\([[0-9]]*\)/\2/'`
-	  os_micro_version=`uname -r | sed 's/\([[0-9]]*\).\([[0-9]]\)\.*\([[0-9]]*\)/\3/'`
+	  os_major_version=`uname -r | sed 's/\([[0-9]]*\).\([[0-9]]*\)\.*\([[0-9]]*\)/\1/'`
+	  os_minor_version=`uname -r | sed 's/\([[0-9]]*\).\([[0-9]]*\)\.*\([[0-9]]*\)/\2/'`
+	  os_micro_version=`uname -r | sed 's/\([[0-9]]*\).\([[0-9]]*\)\.*\([[0-9]]*\)/\3/'`
 	  test -z "$os_micro_version" && os_micro_version=0
-	  os_version_expr="$os_major_version 100 * $os_minor_version 10 * + $os_micro_version + p q"
+	  os_version_expr="$os_major_version 10000 * $os_minor_version 100 * + $os_micro_version + p q"
 	  os_version_code=`echo "$os_version_expr" | dc`
 
 	  AC_MSG_CHECKING(for Solaris release code)
 	  AC_DEFINE_UNQUOTED(GLIBTOP_SOLARIS_RELEASE, $os_version_code,
-              [Solaris release code (eg. 251 for Solaris 2.5.1).])
+              [Solaris release code (eg. 20501 for Solaris 2.5.1).])
 	  AC_MSG_RESULT($os_version_code)
 	  ;;
 	esac
diff -Nrup po/Makefile.in.in po/Makefile.in.in
--- po/Makefile.in.in	2006-04-10 18:26:15.000000000 +0800
+++ po/Makefile.in.in	2006-06-23 17:45:57.201522000 +0800
@@ -39,6 +39,7 @@ MKINSTALLDIRS = $(top_srcdir)/@MKINSTALL
 CC = @CC@
 GENCAT = @GENCAT@
 GMSGFMT = @GMSGFMT@
+GMSGFMT_CHECKOPT = @GMSGFMT_CHECKOPT@
 MSGFMT = @MSGFMT@
 XGETTEXT = @XGETTEXT@
 MSGMERGE = msgmerge
@@ -78,7 +79,7 @@ INSTOBJEXT = @INSTOBJEXT@
 
 .po.gmo:
 	file=$(srcdir)/`echo $* | sed 's,.*/,,'`.gmo \
-	  && rm -f $$file && $(GMSGFMT) -c -o $$file $<
+	  && rm -f $$file && $(GMSGFMT) -o $(GMSGFMT_CHECKOPT) $$file $<
 
 .po.cat:
 	sed -f ../intl/po2msg.sed < $< > $*.msg \
diff -Nrup src/daemon/daemon.h src/daemon/daemon.h
--- src/daemon/daemon.h	2006-04-02 17:10:00.000000000 +0800
+++ src/daemon/daemon.h	2006-06-26 18:39:51.477653000 +0800
@@ -59,17 +59,17 @@ G_BEGIN_DECLS
 #define MSG_BUFSZ		sizeof (struct _glibtop_ipc_message)
 #define MSG_MSGSZ		(MSG_BUFSZ - sizeof (long))
 
-void handle_parent_connection (int s) G_GNUC_INTERNAL;
-void handle_slave_connection (int input, int output) G_GNUC_INTERNAL;
-void handle_slave_command (glibtop_command *cmnd, glibtop_response *resp,
-			   const void *parameter) G_GNUC_INTERNAL ;
-
-void do_output (int s, glibtop_response *resp, off_t offset,
-		size_t data_size, const void *data) G_GNUC_INTERNAL;
-int do_read (int s, void *ptr, size_t total_size) G_GNUC_INTERNAL;
+G_GNUC_INTERNAL void handle_parent_connection (int s) ;
+G_GNUC_INTERNAL void handle_slave_connection (int input, int output) ;
+G_GNUC_INTERNAL void handle_slave_command (glibtop_command *cmnd, glibtop_response *resp,
+			   const void *parameter) ;
+
+G_GNUC_INTERNAL void do_output (int s, glibtop_response *resp, off_t offset,
+		size_t data_size, const void *data) ;
+G_GNUC_INTERNAL int do_read (int s, void *ptr, size_t total_size) ;
 
-void syslog_message (int priority, const char *format, ...) G_GNUC_INTERNAL G_GNUC_PRINTF(2, 3);
-void syslog_io_message (int priority, const char *format, ...) G_GNUC_INTERNAL G_GNUC_PRINTF(2, 3);
+G_GNUC_INTERNAL void syslog_message (int priority, const char *format, ...)  G_GNUC_PRINTF(2, 3);
+G_GNUC_INTERNAL void syslog_io_message (int priority, const char *format, ...)  G_GNUC_PRINTF(2, 3);
 
 extern int enable_debug;
 extern int verbose_output;
diff -Nrup sysdeps/common/fsusage.c sysdeps/common/fsusage.c
--- sysdeps/common/fsusage.c	2005-02-28 16:11:15.000000000 +0800
+++ sysdeps/common/fsusage.c	2006-06-27 12:58:45.589444000 +0800
@@ -126,10 +126,10 @@ static const unsigned long _glibtop_sysd
  */
 
 #ifdef linux
-void
+G_GNUC_INTERNAL void
 _glibtop_linux_get_fsusage_read_write(glibtop *server,
 				      glibtop_fsusage *buf,
-				      const char *path) G_GNUC_INTERNAL;
+				      const char *path) ;
 
 static inline void
 _glibtop_get_fsusage_read_write(glibtop *server,
@@ -141,7 +141,7 @@ _glibtop_get_fsusage_read_write(glibtop 
 
 
 #elif defined(__FreeBSD__)
-void G_GNUC_INTERNAL
+G_GNUC_INTERNAL void
 _glibtop_freebsd_get_fsusage_read_write(glibtop *server,
 					glibtop_fsusage *buf,
 					const char *path);
diff -Nrup sysdeps/common/mountlist.c sysdeps/common/mountlist.c
--- sysdeps/common/mountlist.c	2006-06-24 20:25:03.732980000 +0800
+++ sysdeps/common/mountlist.c	2006-06-22 15:12:57.871145000 +0800
@@ -475,8 +475,10 @@ read_filesystem_list (void)
 	mtail = me;
       }
 
-    if (ret > 0)
+    if (ret > 0) {
+      fclose (fp);
       return NULL;
+    }
    if (fclose (fp) == EOF)
       return NULL;
   }
@@ -610,7 +612,7 @@ glibtop_get_mountlist_s (glibtop *server
 	buf->total  = buf->number * buf->size;
 
 	buf->flags  = (1 << GLIBTOP_MOUNTLIST_SIZE)
-	  | (1 << GLIBTOP_MOUNTLIST_SIZE)
+	  | (1 << GLIBTOP_MOUNTLIST_NUMBER)
 	  | (1 << GLIBTOP_MOUNTLIST_TOTAL);
 
 	return (glibtop_mountentry*) g_array_free(mount_array, FALSE);
diff -Nrup sysdeps/solaris/Makefile.am sysdeps/solaris/Makefile.am
--- sysdeps/solaris/Makefile.am	2004-11-13 08:53:20.000000000 +0800
+++ sysdeps/solaris/Makefile.am	2006-06-26 16:29:13.805833000 +0800
@@ -8,6 +8,7 @@ libgtop_sysdeps_2_0_la_SOURCES	= open.c 
 				  proclist.c procstate.c procuid.c \
 				  proctime.c procmem.c procsignal.c \
 				  prockernel.c procsegment.c procargs.c \
+                                  procopenfiles.c sysinfo.c \
 				  procmap.c netload.c ppp.c procdata.c netlist.c
 
 libgtop_sysdeps_2_0_la_LDFLAGS	= $(LT_VERSION_INFO)
diff -Nrup sysdeps/solaris/cpu.c sysdeps/solaris/cpu.c
--- sysdeps/solaris/cpu.c	2005-12-12 18:09:40.000000000 +0800
+++ sysdeps/solaris/cpu.c	2006-06-27 18:59:31.656908000 +0800
@@ -36,6 +36,7 @@ static const unsigned long _glibtop_sysd
 
 static const unsigned long _glibtop_sysdeps_cpu_all =
 (1L << GLIBTOP_CPU_TOTAL) + (1L << GLIBTOP_CPU_USER) +
+(1L << GLIBTOP_CPU_NICE) +
 (1L << GLIBTOP_CPU_SYS) + (1L << GLIBTOP_CPU_IDLE) +
 (1L << GLIBTOP_XCPU_TOTAL) + (1L << GLIBTOP_XCPU_USER) +
 (1L << GLIBTOP_XCPU_SYS) + (1L << GLIBTOP_XCPU_IDLE) +
diff -Nrup sysdeps/solaris/glibtop_machine.h sysdeps/solaris/glibtop_machine.h
--- sysdeps/solaris/glibtop_machine.h	2004-06-10 02:52:22.000000000 +0800
+++ sysdeps/solaris/glibtop_machine.h	2006-07-16 19:03:50.987999000 +0800
@@ -63,14 +63,8 @@ struct _glibtop_machine
     int pagesize;		/* in bits to shift, ie. 2^pagesize gives Kb */
     int ticks;			/* clock ticks, as returned by sysconf() */
     unsigned long long boot;	/* boot time, although it's ui32 in kstat */
-    void *libproc;		/* libproc handle */
-#if GLIBTOP_SOLARIS_RELEASE >= 560
-    void (*objname)(void *, uintptr_t, const char *, size_t);
-    struct ps_prochandle *(*pgrab)(pid_t, int, int *);
-    void (*pfree)(void *);
-#else
+
     void *filler[3];
-#endif
 };
 
 G_END_DECLS
diff -Nrup sysdeps/solaris/glibtop_server.h sysdeps/solaris/glibtop_server.h
--- sysdeps/solaris/glibtop_server.h	2005-08-12 22:55:37.000000000 +0800
+++ sysdeps/solaris/glibtop_server.h	2006-07-30 14:25:47.137664000 +0800
@@ -31,9 +31,15 @@ G_BEGIN_DECLS
 #define GLIBTOP_SUID_SWAP		0
 #define GLIBTOP_SUID_UPTIME		0
 #define GLIBTOP_SUID_LOADAVG		0
+#if GLIBTOP_SOLARIS_RELEASE < 51000
 #define GLIBTOP_SUID_SHM_LIMITS		(1L << GLIBTOP_SYSDEPS_SHM_LIMITS)
 #define GLIBTOP_SUID_MSG_LIMITS		(1L << GLIBTOP_SYSDEPS_MSG_LIMITS)
 #define GLIBTOP_SUID_SEM_LIMITS		(1L << GLIBTOP_SYSDEPS_SEM_LIMITS)
+#else
+#define GLIBTOP_SUID_SHM_LIMITS         0
+#define GLIBTOP_SUID_MSG_LIMITS         0
+#define GLIBTOP_SUID_SEM_LIMITS         0
+#endif
 #define GLIBTOP_SUID_PROCLIST		0
 #define GLIBTOP_SUID_PROC_STATE		0
 #define GLIBTOP_SUID_PROC_UID		0
diff -Nrup sysdeps/solaris/msg_limits.c sysdeps/solaris/msg_limits.c
--- sysdeps/solaris/msg_limits.c	2005-12-12 18:09:40.000000000 +0800
+++ sysdeps/solaris/msg_limits.c	2006-07-30 20:21:13.770377000 +0800
@@ -26,47 +26,76 @@
 #include <glibtop/msg_limits.h>
 
 #include <kvm.h>
+#include <rctl.h>
 #include <sys/msg.h>
 
-static const struct nlist nlst[] = { {"msginfo"}, {NULL} };
+static const struct nlist nlst[] = { {"glibtop_msg_limits"}, {NULL} };
+#if GLIBTOP_SOLARIS_RELEASE < 51000
 static const unsigned long _glibtop_sysdeps_msg_limits =
-#if GLIBTOP_SOLARIS_RELEASE <= 570
+#if GLIBTOP_SOLARIS_RELEASE <= 50700
 (1L << GLIBTOP_IPC_MSGMAP) +  (1L << GLIBTOP_IPC_MSGSSZ) +
 #endif
 (1L << GLIBTOP_IPC_MSGPOOL) + (1L << GLIBTOP_IPC_MSGMAX) +
 (1L << GLIBTOP_IPC_MSGMNB) + (1L << GLIBTOP_IPC_MSGMNI) +
 (1L << GLIBTOP_IPC_MSGTQL);
+#else
+/*static const unsigned long _glibtop_sysdeps_msg_limits = 0;*/
+static const unsigned long _glibtop_sysdeps_msg_limits =
+(1L << GLIBTOP_IPC_MSGMNB) +
+(1L << GLIBTOP_IPC_MSGMNI) +
+(1L << GLIBTOP_IPC_MSGMAX) +
+(1L << GLIBTOP_IPC_MSGPOOL) +
+(1L << GLIBTOP_IPC_MSGTQL);
+#endif
+
 
 /* Init function. */
 
+#if GLIBTOP_SUID_MSG_LIMITS
 void
 glibtop_init_msg_limits_p (glibtop *server)
+#else
+void
+glibtop_init_msg_limits_s (glibtop *server)
+#endif 
 {
+#if GLIBTOP_SOLARIS_RELEASE < 51000
+
    	kvm_t *kd = server->machine.kd;
 
 	if(kd && !kvm_nlist(kd, nlst))
 		server->sysdeps.msg_limits = _glibtop_sysdeps_msg_limits;
 	else
 	   	server->sysdeps.msg_limits = 0;
+#endif
 }
 
 /* Provides information about sysv ipc limits. */
 
+#if GLIBTOP_SUID_MSG_LIMITS
 void
 glibtop_get_msg_limits_p (glibtop *server, glibtop_msg_limits *buf)
+#else
+void
+glibtop_get_msg_limits_s (glibtop *server, glibtop_msg_limits *buf)
+#endif 
 {
+#if GLIBTOP_SOLARIS_RELEASE < 51000
+
    	kvm_t *kd = server->machine.kd;
-	struct msginfo minfo;
+        glibtop_msg_limits minfo;
+
 
 	memset (buf, 0, sizeof (glibtop_msg_limits));
 
 	if(!(server->sysdeps.msg_limits))
 	   	return;
 	if(kvm_read(kd, nlst[0].n_value, (void *)&minfo,
-		    sizeof(struct msginfo)) != sizeof(struct msginfo))
+                    sizeof(glibtop_msg_limits)) != sizeof(glibtop_msg_limits))
+
 	   	return;
 
-#if GLIBTOP_SOLARIS_RELEASE <= 570
+#if GLIBTOP_SOLARIS_RELEASE <= 50700
 	/* These fields don't exist anymore in Solaris 8.
 	 * Thanks to Laszlo PETER <Laszlo.Peter@ireland.sun.com>. */
 	buf->msgmap = minfo.msgmap;
@@ -76,6 +105,33 @@ glibtop_get_msg_limits_p (glibtop *serve
 	buf->msgmnb = minfo.msgmnb;
 	buf->msgmni = minfo.msgmni;
 	buf->msgtql = minfo.msgtql;
-	buf->msgpool = minfo.msgmni * minfo.msgmnb >> 10;
-	buf->flags = _glibtop_sysdeps_msg_limits;
+#endif
+#if GLIBTOP_SOLARIS_RELEASE >= 51000
+       rctlblk_t *rblk;
+       if ((rblk = malloc(rctlblk_size())) == NULL)
+               return;
+
+       if (getrctl("project.max-msg-qbytes", NULL, rblk, RCTL_FIRST) == -1)
+               return;
+       else
+               buf->msgmnb = rctlblk_get_value(rblk);
+
+       if (getrctl("project.max-msg-ids", NULL, rblk, RCTL_FIRST) == -1)
+               return;
+       else
+               buf->msgmni = rctlblk_get_value(rblk);
+
+       if (getrctl("project.max-msg-messages", NULL, rblk, RCTL_FIRST) == -1)
+               return;
+       else
+               buf->msgtql = rctlblk_get_value(rblk);
+       /* this is the maximum size of a system V message, which has been obsoleted as a kernel tunable value now */
+       /* and it should always be 65535 instead, so I list it here, if needed, can be removed */	       
+       buf->msgmax = 65535;
+       
+#endif
+
+       buf->msgpool = buf->msgmni * buf->msgmnb >> 10;
+       buf->flags = _glibtop_sysdeps_msg_limits;
+
 }
diff -Nrup sysdeps/solaris/netlist.c sysdeps/solaris/netlist.c
--- sysdeps/solaris/netlist.c	2005-12-12 18:09:40.000000000 +0800
+++ sysdeps/solaris/netlist.c	2006-05-14 19:17:06.524772000 +0800
@@ -50,13 +50,19 @@ glibtop_get_netlist_s (glibtop *server, 
 	devices = g_ptr_array_new();
 
 	kc = kstat_open();
-
+	if (kc == NULL){
+		glibtop_warn_io_r (server, "kstat_open ()");
+		buf->number = 0;
+		return 0;
+	}
+	
 	for (ksp = kc->kc_chain; ksp; ksp = ksp->ks_next)
 	{
 		if (strcmp(ksp->ks_class, "net") != 0)
 			continue;
 
 		g_ptr_array_add(devices, g_strdup(ksp->ks_name));
+		buf->number++;
 	}
 
 	kstat_close(kc);
diff -Nrup sysdeps/solaris/netload.c sysdeps/solaris/netload.c
--- sysdeps/solaris/netload.c	2005-12-12 18:09:40.000000000 +0800
+++ sysdeps/solaris/netload.c	2006-07-27 17:24:49.428904000 +0800
@@ -26,14 +26,248 @@
 #include <glibtop/error.h>
 #include <glibtop/netload.h>
 
-static const unsigned long _glibtop_sysdeps_netload = 0;
+#include "glibtop_private.h"
+
+#include <errno.h>
+#include <string.h>
+
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/ioctl.h>
+#include <sys/sockio.h>
+
+//#if !defined (_LIBC) && defined (__GNU_LIBRARY__) && __GNU_LIBRARY__ > 1
+/* GNU LibC */
+#include <net/if.h>
+
+#ifdef HAVE_IFADDRS_H
+/* needed for IPV6 support */
+
+#include <ifaddrs.h>
+
+#ifndef IN6_IS_ADDR_GLOBAL
+#define IN6_IS_ADDR_GLOBAL(a) \
+   (((((__const uint8_t *) (a))[0] & 0xff) == 0x3f   \
+     || (((__const uint8_t *) (a))[0] & 0xff) == 0x20))
+#endif
+#endif /* HAVE_IFADDRS_H */
+
+static const unsigned long _glibtop_sysdeps_netload =
+(1L << GLIBTOP_NETLOAD_ERRORS_IN) +
+(1L << GLIBTOP_NETLOAD_ERRORS_OUT) +
+(1L << GLIBTOP_NETLOAD_COLLISIONS);
+
+static const unsigned long _glibtop_sysdeps_netload_data =
+(1L << GLIBTOP_NETLOAD_ADDRESS) +
+(1L << GLIBTOP_NETLOAD_SUBNET) +
+(1L << GLIBTOP_NETLOAD_MTU);
+
+static const unsigned long _glibtop_sysdeps_netload_bytes =
+(1L << GLIBTOP_NETLOAD_BYTES_IN) +
+(1L << GLIBTOP_NETLOAD_BYTES_OUT) +
+(1L << GLIBTOP_NETLOAD_BYTES_TOTAL);
+
+static const unsigned long _glibtop_sysdeps_netload_packets =
+(1L << GLIBTOP_NETLOAD_PACKETS_IN) +
+(1L << GLIBTOP_NETLOAD_PACKETS_OUT) +
+(1L << GLIBTOP_NETLOAD_PACKETS_TOTAL);
+
+static const unsigned long _glibtop_sysdeps_netload_total =
+(1L << GLIBTOP_NETLOAD_PACKETS_TOTAL) +
+(1L << GLIBTOP_NETLOAD_BYTES_TOTAL);
+
+static const unsigned long _glibtop_sysdeps_netload_in =
+(1L << GLIBTOP_NETLOAD_PACKETS_TOTAL) +
+(1L << GLIBTOP_NETLOAD_BYTES_TOTAL) +
+(1L << GLIBTOP_NETLOAD_PACKETS_IN) +
+(1L << GLIBTOP_NETLOAD_BYTES_IN);
+
+static const unsigned long _glibtop_sysdeps_netload_out =
+(1L << GLIBTOP_NETLOAD_PACKETS_TOTAL) +
+(1L << GLIBTOP_NETLOAD_BYTES_TOTAL) +
+(1L << GLIBTOP_NETLOAD_PACKETS_OUT) +
+(1L << GLIBTOP_NETLOAD_BYTES_OUT);
+
+static const unsigned long _glibtop_sysdeps_netload_6 =
+(1L << GLIBTOP_NETLOAD_ADDRESS6) +
+(1L << GLIBTOP_NETLOAD_PREFIX6) +
+(1L << GLIBTOP_NETLOAD_SCOPE6);
+
 
 /* Init function. */
 
 void
 glibtop_init_netload_s (glibtop *server)
 {
-	server->sysdeps.netload = _glibtop_sysdeps_netload;
+    server->sysdeps.netload = _glibtop_sysdeps_netload |
+	_glibtop_sysdeps_netload_bytes |
+	_glibtop_sysdeps_netload_packets;
+}
+
+
+#ifdef HAVE_IFADDRS_H
+
+static void get_ipv6(glibtop *server, glibtop_netload *buf,
+		     const char *interface)
+{
+/* 
+  * remove this code, because they are not available at Solaris, but keep them here for reference.
+  * in fact, the function will not be called at Solaris, because HAVE_IFADDRS_H don't def.
+  *
+	struct ifaddrs *ifa0, *ifr6;
+
+	if(getifaddrs (&ifa0) != 0)
+	{
+		glibtop_warn_r(server, "getifaddrs failed : %s", g_strerror(errno));
+		return;
+	}
+
+	for (ifr6 = ifa0; ifr6; ifr6 = ifr6->ifa_next) {
+		if (strcmp (ifr6->ifa_name, interface) == 0
+		    && ifr6->ifa_addr != NULL
+		    && ifr6->ifa_addr->sa_family == AF_INET6)
+			break;
+	}
+
+	if(!ifr6) goto free_ipv6;
+
+	memcpy(buf->address6,
+	       &((struct sockaddr_in6 *) ifr6->ifa_addr)->sin6_addr,
+	       16);
+
+	memcpy(buf->prefix6,
+	       &((struct sockaddr_in6 *) ifr6->ifa_netmask)->sin6_addr,
+	       16);
+
+
+	if (IN6_IS_ADDR_LINKLOCAL (buf->address6))
+		buf->scope6 = GLIBTOP_IF_IN6_SCOPE_LINK;
+
+	else if (IN6_IS_ADDR_SITELOCAL (buf->address6))
+		buf->scope6 = GLIBTOP_IF_IN6_SCOPE_SITE;
+
+	else if (IN6_IS_ADDR_GLOBAL (buf->address6)
+		 || IN6_IS_ADDR_MC_ORGLOCAL (buf->address6)
+		 || IN6_IS_ADDR_V4COMPAT (buf->address6)
+		 || IN6_IS_ADDR_MULTICAST (buf->address6)
+		 || IN6_IS_ADDR_UNSPECIFIED (buf->address6)
+		)
+		buf->scope6 = GLIBTOP_IF_IN6_SCOPE_GLOBAL;
+
+	else if (IN6_IS_ADDR_LOOPBACK (buf->address6))
+		buf->scope6 = GLIBTOP_IF_IN6_SCOPE_HOST;
+
+	else
+		buf->scope6 = GLIBTOP_IF_IN6_SCOPE_UNKNOWN;
+
+	buf->flags |= _glibtop_sysdeps_netload_6;
+
+ free_ipv6:
+	freeifaddrs(ifa0);
+*/
+}
+
+#endif /* HAVE_IFADDRS_H */
+
+
+
+static int
+solaris_stats(glibtop *server,
+		glibtop_netload *buf,
+		const char *interface)
+{
+	char	*name = interface;
+	char	*module;
+	char	*ptr;
+	kstat_ctl_t		*kctl;
+	kstat_t			*ksp;
+	kstat_named_t		*kdata;
+	int have_bytes = 1;
+
+	/*
+	 *  chop off the trailing interface and 
+	 */
+	module = strdup( name );
+	ptr = module + strlen( module ) - 1;
+	while( (ptr > module) && isdigit( (int) *ptr ) ) {
+		*ptr = '\0';
+		ptr--;
+	}
+
+	/*
+	 *  get a kstat handle and update the user's kstat chain
+	 */
+	if( (kctl = kstat_open()) == NULL ){
+		glibtop_warn_io_r (server, "kstat_open ()");
+		free( module );
+		return( 0 );
+	}
+	while( kstat_chain_update( kctl ) != 0 )
+		;
+
+	/*
+	 *  traverse the kstat chain
+	 *  to find the appropriate statistics
+	 */
+	if( (ksp = kstat_lookup( kctl,
+			module, 0, name )) == NULL ) {
+		free( module );
+		kstat_close(kctl);
+		return( 0 );
+	}
+	if( kstat_read( kctl, ksp, NULL ) == -1 ) {
+		free( module );
+		kstat_close(kctl);
+		return( 0 );
+	}
+	free( module );
+
+	/*
+	 *  lookup & store the data
+	 */
+	kdata = (kstat_named_t *) kstat_data_lookup( ksp, "ipackets" );
+	if( kdata != NULL ) {
+		buf->packets_in= kdata->value.ul;
+	}
+	kdata = (kstat_named_t *) kstat_data_lookup( ksp, "opackets" );
+	if( kdata != NULL ) {
+		buf->packets_out = kdata->value.ul;
+	}
+	kdata = (kstat_named_t *) kstat_data_lookup( ksp, "rbytes" );
+	if( kdata != NULL ) {
+		buf->bytes_in =kdata->value.ul;
+	}
+	kdata = (kstat_named_t *) kstat_data_lookup( ksp, "obytes" );
+	if( kdata != NULL ) {
+		buf->bytes_out =kdata->value.ul;
+	}
+	kdata = (kstat_named_t *) kstat_data_lookup( ksp, "ierrors" );
+	if( kdata != NULL ) {
+		buf->errors_in = kdata->value.ul;
+	}
+	kdata = (kstat_named_t *) kstat_data_lookup( ksp, "oerrors" );
+	if( kdata != NULL ) {
+		buf->errors_out = kdata->value.ul;
+	}
+	kdata = (kstat_named_t *) kstat_data_lookup( ksp, "collisions" );
+	if( kdata != NULL ) {
+		buf->collisions = kdata->value.ul;
+	}
+	
+	/* Compute total valules. */
+
+	buf->bytes_total = buf->bytes_in + buf->bytes_out;
+	buf->packets_total = buf->packets_in + buf->packets_out;
+	buf->errors_total = buf->errors_in + buf->errors_out;
+	/* And now the flags. */
+	buf->flags |= _glibtop_sysdeps_netload;
+	buf->flags |= _glibtop_sysdeps_netload_bytes;
+	buf->flags |= _glibtop_sysdeps_netload_packets;
+	    
+	kstat_close(kctl);
+
+	/* finished */
+	
 }
 
 /* Provides network statistics. */
@@ -42,5 +276,73 @@ void
 glibtop_get_netload_s (glibtop *server, glibtop_netload *buf,
 		       const char *interface)
 {
-	memset (buf, 0, sizeof (glibtop_netload));
+    int skfd;
+    memset (buf, 0, sizeof (glibtop_netload));
+
+    /* set flag */
+    skfd = socket (PF_INET, SOCK_DGRAM, 0);
+    if (skfd) {
+	struct ifreq ifr;
+
+	g_strlcpy (ifr.ifr_name, interface, sizeof ifr.ifr_name);
+	if (ioctl (skfd, SIOCGIFFLAGS, &ifr) >= 0) {
+	    const unsigned long long flags = ifr.ifr_flags;
+
+	    buf->flags |= (1L << GLIBTOP_NETLOAD_IF_FLAGS);
+
+	    if (flags & IFF_UP)
+		buf->if_flags |= (1L << GLIBTOP_IF_FLAGS_UP);
+
+	    if (flags & IFF_BROADCAST)
+		buf->if_flags |= (1L << GLIBTOP_IF_FLAGS_BROADCAST);
+
+	    if (flags & IFF_DEBUG)
+		buf->if_flags |= (1L << GLIBTOP_IF_FLAGS_DEBUG);
+
+	    if (flags & IFF_LOOPBACK)
+		buf->if_flags |= (1L << GLIBTOP_IF_FLAGS_LOOPBACK);
+
+	    if (flags & IFF_POINTOPOINT)
+		buf->if_flags |= (1L << GLIBTOP_IF_FLAGS_POINTOPOINT);
+
+	    if (flags & IFF_RUNNING)
+		buf->if_flags |= (1L << GLIBTOP_IF_FLAGS_RUNNING);
+
+	    if (flags & IFF_NOARP)
+		buf->if_flags |= (1L << GLIBTOP_IF_FLAGS_NOARP);
+
+	    if (flags & IFF_PROMISC)
+		buf->if_flags |= (1L << GLIBTOP_IF_FLAGS_PROMISC);
+
+	    if (flags & IFF_ALLMULTI)
+		buf->if_flags |= (1L << GLIBTOP_IF_FLAGS_ALLMULTI);
+
+	    if (flags & IFF_MULTICAST)
+		buf->if_flags |= (1L << GLIBTOP_IF_FLAGS_MULTICAST);
+	    }
+
+	g_strlcpy (ifr.ifr_name, interface, sizeof ifr.ifr_name);
+	if (!ioctl (skfd, SIOCGIFADDR, &ifr)) {
+	    buf->address = ((struct sockaddr_in *) &ifr.ifr_addr)->sin_addr.s_addr;
+	    buf->flags |= (1L << GLIBTOP_NETLOAD_ADDRESS);
+	}
+
+	g_strlcpy (ifr.ifr_name, interface, sizeof ifr.ifr_name);
+	if (!ioctl (skfd, SIOCGIFNETMASK, &ifr)) {
+	    buf->subnet = ((struct sockaddr_in *) &ifr.ifr_addr)->sin_addr.s_addr;
+	    buf->flags |= (1L << GLIBTOP_NETLOAD_SUBNET);
+	}
+	close (skfd);
+    }
+
+    /*
+     * Statistics
+     */
+     
+    solaris_stats(server, buf, interface);
+
+#ifdef HAVE_IFADDRS_H
+    get_ipv6(server, buf, interface);
+#endif /* HAVE_IFADDRS_H */
 }
+
diff -Nrup sysdeps/solaris/open.c sysdeps/solaris/open.c
--- sysdeps/solaris/open.c	2005-12-12 18:09:40.000000000 +0800
+++ sysdeps/solaris/open.c	2006-07-16 18:17:35.524466000 +0800
@@ -83,7 +83,8 @@ glibtop_get_kstats(glibtop *server)
 	    char cpu[20];
 
 	    for(i = 0, checked = 0; i < GLIBTOP_NCPU || checked == new_ncpu; ++i)
-		if(server->machine.cpu_stat_kstat[i])
+                if(!server->machine.cpu_stat_kstat[i])
+
 		{
 		    sprintf(cpu, "cpu_stat%d", i);
 		    if(!(server->machine.cpu_stat_kstat[i] =
@@ -145,6 +146,8 @@ glibtop_open_s (glibtop *server, const c
     for(i = 0; page; ++i, page >>= 1);
     server->machine.pagesize = i - 1;
     server->machine.ticks = sysconf(_SC_CLK_TCK);
+    if(server->machine.kc)
+    	kstat_close(server->machine.kc);
     server->machine.kc = kc = kstat_open ();
 
 #if 0
@@ -208,31 +211,5 @@ glibtop_open_s (glibtop *server, const c
 	    }
     }
 
-    /* Now let's have a bit of magic dust... */
-
-#if GLIBTOP_SOLARIS_RELEASE >= 560
-
-    dl = dlopen("/usr/lib/libproc.so", RTLD_LAZY);
-    server->machine.libproc = dl;
-    if(dl)
-    {
-       void *func;
-
-       func = dlsym(dl, "Pobjname");		/* Solaris 8 */
-       if(!func)
-	  func = dlsym(dl, "proc_objname");	/* Solaris 7 */
-       server->machine.objname = (void (*)
-				 (void *, uintptr_t, const char *, size_t))func;
-       server->machine.pgrab = (struct ps_prochandle *(*)(pid_t, int, int *))
-	  		       dlsym(dl, "Pgrab");
-       server->machine.pfree = (void (*)(void *))dlsym(dl, "Pfree");
-    }
-    else
-    {
-       server->machine.objname = NULL;
-       server->machine.pgrab = NULL;
-       server->machine.pfree = NULL;
-    }
-#endif
     server->machine.me = getpid();
 }
diff -Nrup sysdeps/solaris/open_suid.c sysdeps/solaris/open_suid.c
--- sysdeps/solaris/open_suid.c	2005-12-12 18:09:40.000000000 +0800
+++ sysdeps/solaris/open_suid.c	2006-06-21 18:26:27.064462000 +0800
@@ -69,9 +69,13 @@ glibtop_open_p (glibtop *server, const c
 	server->machine.gid = getgid ();
 	server->machine.egid = getegid ();
 
+#if GLIBTOP_SOLARIS_RELEASE < 51000
+
 	server->machine.kd = kvm_open(NULL, NULL, NULL, O_RDONLY, NULL);
 	if(!server->machine.kd)
 		glibtop_warn_io_r(server, "kvm_open()");
+		
+#endif
 
 	/* Drop priviledges; we only become root when necessary.
 
diff -Nrup sysdeps/solaris/procmap.c sysdeps/solaris/procmap.c
--- sysdeps/solaris/procmap.c	2005-12-12 18:09:40.000000000 +0800
+++ sysdeps/solaris/procmap.c	2006-07-31 20:45:36.318376000 +0800
@@ -56,7 +56,8 @@ glibtop_map_entry *
 glibtop_get_proc_map_s (glibtop *server, glibtop_proc_map *buf,	pid_t pid)
 {
    	int fd, i, nmaps, pr_err, heap;
-#if GLIBTOP_SOLARIS_RELEASE >= 560
+	char filename [BUFSIZ];
+#if GLIBTOP_SOLARIS_RELEASE >= 50600
 	prxmap_t *maps;
 	struct ps_prochandle *Pr = NULL;
 #else
@@ -84,7 +85,7 @@ glibtop_get_proc_map_s (glibtop *server,
 #endif
 	if((fd = s_open(buffer, O_RDONLY)) < 0)
 	{
-	   	if(errno != EPERM && errno != EACCES)
+	   	if (errno != EPERM && errno != EACCES)
 		   	glibtop_warn_io_r(server, "open (%s)", buffer);
 		return NULL;
 	}
@@ -125,20 +126,14 @@ glibtop_get_proc_map_s (glibtop *server,
 	buf->total = nmaps * sizeof(glibtop_map_entry);
 	entry = g_malloc0(buf->total);
 
-#if GLIBTOP_SOLARIS_RELEASE >= 560
-
-	if(server->machine.objname && server->machine.pgrab &&
-	   server->machine.pfree)
-	   Pr = (server->machine.pgrab)(pid, 1, &pr_err);
-#endif
 	for(heap = 0,i = 0; i < nmaps; ++i)
 	{
-	   	int len;
+	   	int len, rv;
 
 	   	entry[i].start = maps[i].pr_vaddr;
 		entry[i].end = maps[i].pr_vaddr + maps[i].pr_size;
 
-#if GLIBTOP_SOLARIS_RELEASE >= 560
+#if GLIBTOP_SOLARIS_RELEASE >= 50600
 
 		if(maps[i].pr_dev != PRNODEV)
 		{
@@ -150,17 +145,21 @@ glibtop_get_proc_map_s (glibtop *server,
 		entry[i].offset = maps[i].OFFSET;
 		if(maps[i].pr_mflags & MA_READ)
 		   	entry[i].perm |= GLIBTOP_MAP_PERM_READ;
-		if(maps[i].pr_mflags & MA_WRITE)
+		if(maps[i].pr_mflags & MA_WRITE){
 		   	entry[i].perm |= GLIBTOP_MAP_PERM_WRITE;
+		   	entry[i].size = maps[i].pr_size;
+		}
 		if(maps[i].pr_mflags & MA_EXEC)
 		   	entry[i].perm |= GLIBTOP_MAP_PERM_EXECUTE;
-		if(maps[i].pr_mflags & MA_SHARED)
-		   	entry[i].perm |= GLIBTOP_MAP_PERM_SHARED;
+		if(maps[i].pr_mflags & MA_SHARED){
+		   	entry[i].perm |= GLIBTOP_MAP_PERM_SHARED;		
+		   	entry[i].shared_clean = maps[i].pr_size; /* here use shared_clean to store Shared Memory */
+		}
 		else
 		   	entry[i].perm |= GLIBTOP_MAP_PERM_PRIVATE;
 		entry[i].flags = _glibtop_sysdeps_map_entry;
 
-#if GLIBTOP_SOLARIS_RELEASE >= 560
+#if GLIBTOP_SOLARIS_RELEASE >= 50600
 
 		if(maps[i].pr_mflags & MA_ANON)
 		{
@@ -177,25 +176,24 @@ glibtop_get_proc_map_s (glibtop *server,
 		   entry[i].flags |= (1L << GLIBTOP_MAP_ENTRY_FILENAME);
 		}
 		else
-		   if(Pr)
-		   {
-		      server->machine.objname(Pr, maps[i].pr_vaddr, buffer,
-					      BUFSIZ);
-		      if((len = resolvepath(buffer, entry[i].filename,
-					    GLIBTOP_MAP_FILENAME_LEN)) > 0)
-		      {
-			 entry[i].filename[len] = 0;
-			 entry[i].flags |= (1L << GLIBTOP_MAP_ENTRY_FILENAME);
-		      }
-		   }
+		{
+			strcpy(buffer, maps[i].pr_mapname);
+			/* from /path get file name */
+			g_snprintf(filename, sizeof filename, "/proc/%d/path/%s",
+			   	pid, buffer);
+
+			rv = readlink(filename, entry[i].filename, sizeof(entry[i].filename) - 1);
+			/* read object, if have not, set it as NULL */
+			if(rv < 0) 
+				rv = 0;
+			entry[i].filename[rv] = '\0';
+			/* now set the flags */	
+			entry[i].flags |= (1L << GLIBTOP_MAP_ENTRY_FILENAME);
+		}
+
 #endif
 	}
 
-#if GLIBTOP_SOLARIS_RELEASE >= 560
-
-	if(Pr)
-	   	server->machine.pfree(Pr);
-#endif
 	buf->flags = _glibtop_sysdeps_proc_map;
 	s_close(fd);
 	return entry;
diff -Nrup sysdeps/solaris/procmem.c sysdeps/solaris/procmem.c
--- sysdeps/solaris/procmem.c	2005-12-12 18:09:40.000000000 +0800
+++ sysdeps/solaris/procmem.c	2006-07-27 17:46:54.746973000 +0800
@@ -24,6 +24,7 @@
 #include <config.h>
 #include <glibtop.h>
 #include <glibtop/procmem.h>
+#include <glibtop/procmap.h>
 
 #include "glibtop_private.h"
 
@@ -59,9 +60,25 @@ glibtop_get_proc_mem_s (glibtop *server,
 #ifdef HAVE_PROCFS_H
 	buf->size = buf->vsize = psinfo.pr_size << 10;
 	buf->resident = buf->rss = psinfo.pr_rssize << 10;
+	buf->load = (guint) psinfo.pr_lwp.pr_pctcpu * 100 / (guint) 0x8000;
 #else
 	buf->size = buf->vsize = psinfo.pr_size << pagesize << 10;
 	buf->resident = buf->rss = psinfo.pr_rssize << pagesize << 10;
+	buf->load = (guint) psinfo.pr_lwp.pr_pctcpu * 100 / (guint) 0x8000;
 #endif
+/* get Shared Memory  */
+	glibtop_proc_map mapbuf;
+	glibtop_map_entry *maps;
+	unsigned i;
+	buf->share = 0;
+	
+	maps = glibtop_get_proc_map_s(server, &mapbuf, pid);
+	
+	for (i = 0; i < mapbuf.number; ++i) {
+		if (maps[i].perm & GLIBTOP_MAP_PERM_SHARED)
+			buf->share += maps[i].shared_clean;
+	}
+	g_free(maps);
+		
 	buf->flags = _glibtop_sysdeps_proc_mem;
 }
diff -Nrup sysdeps/solaris/procopenfiles.c sysdeps/solaris/procopenfiles.c
--- sysdeps/solaris/procopenfiles.c	1970-01-01 08:00:00.000000000 +0800
+++ sysdeps/solaris/procopenfiles.c	2006-07-27 16:56:26.058116000 +0800
@@ -0,0 +1,134 @@
+/* $Id: procopenfiles.c,v 1.7 2005/12/12 09:38:12 jamesh Exp $ */
+
+/* Copyright (C) 2006 Henry Zhang
+   This file is part of LibGTop 2.14.
+
+   Contributed by Henry Zhang <hua.zhang@sun.com>, July 2006.
+
+   LibGTop is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License,
+   or (at your option) any later version.
+
+   LibGTop is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+   for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with LibGTop; see the file COPYING. If not, write to the
+   Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+
+#include <config.h>
+#include <glibtop.h>
+#include <glibtop/error.h>
+#include <glibtop/procopenfiles.h>
+#include <sys/types.h>
+#include <fcntl.h>
+#include <sys/stat.h>
+#include <dirent.h>
+#include <string.h>
+#include <stdio.h>
+
+#include "glibtop_private.h"
+
+static const unsigned long _glibtop_sysdeps_proc_open_files =
+(1L << GLIBTOP_PROC_OPEN_FILES_NUMBER)|
+(1L << GLIBTOP_PROC_OPEN_FILES_TOTAL)|
+(1L << GLIBTOP_PROC_OPEN_FILES_SIZE);
+
+/* Init function. */
+
+void
+glibtop_init_proc_open_files_s (glibtop *server)
+{
+	server->sysdeps.proc_open_files = _glibtop_sysdeps_proc_open_files;
+}
+
+
+
+/* Provides detailed information about a process' open files */
+
+glibtop_open_files_entry *
+glibtop_get_proc_open_files_s (glibtop *server, glibtop_proc_open_files *buf,	pid_t pid)
+{
+	char filename [BUFSIZ];
+	GArray *entries;
+	struct dirent *direntry;
+	DIR *dir;
+	int errno;
+
+	glibtop_init_s (&server, GLIBTOP_SYSDEPS_PROC_OPEN_FILES, 0);
+
+	memset (buf, 0, sizeof (glibtop_proc_open_files));
+
+	sprintf (filename, "/proc/%d/fd", pid);
+
+	dir = opendir (filename);
+	if (!dir) return NULL;
+
+	entries = g_array_new(FALSE, FALSE, sizeof(glibtop_open_files_entry));
+
+	while((direntry = readdir(dir))) {
+		char tgt [BUFSIZ];
+		int rv;
+		glibtop_open_files_entry entry = {0};
+		struct stat statbuf;
+
+		if(direntry->d_name[0] == '.')
+			continue;
+		/* at /path, there are some dir which are not fd, so need to skip them */
+
+		/* Clear error for atoi return */
+		errno = 0;
+		entry.fd = atoi(direntry->d_name);
+		if (entry.fd == 0 && errno != 0)
+			continue;
+					
+		/* from /path get object name */
+		g_snprintf(filename, sizeof filename, "/proc/%d/path/%s",
+			   pid, direntry->d_name);
+
+		rv = readlink(filename, tgt, sizeof(tgt) - 1);
+		/* read object, if not have, set it as NULL, but this fd still need to insert into the array */
+		if(rv < 0) 
+			rv = 0;
+		tgt[rv] = '\0';
+		
+		/* from /fd get the stat data */
+		g_snprintf(filename, sizeof filename, "/proc/%d/fd/%s",
+			   pid, direntry->d_name);
+
+		if(stat (filename, &statbuf))
+			statbuf.st_mode = 0;		
+
+		switch (statbuf.st_mode & S_IFMT) {
+			case S_IFIFO:    /* pipe */
+				entry.type = GLIBTOP_FILE_TYPE_PIPE;
+				break;
+			case S_IFSOCK:	/* socket */
+			/* at solaris, now a little difficult to tell the Socket type, so here I 
+			   give the type 0, it will not impact the existed code. Later will provide 
+			   a patch to tell the type, and get the object name */
+				entry.type = 0;
+				break;
+			default:
+				entry.type = GLIBTOP_FILE_TYPE_FILE;
+		}
+				
+		g_strlcpy(entry.info.file.name, tgt, sizeof entry.info.file.name);
+
+		g_array_append_val(entries, entry);
+	}
+
+	closedir (dir);
+
+	buf->flags = _glibtop_sysdeps_proc_open_files;
+	buf->number = entries->len;
+	buf->size = sizeof(glibtop_open_files_entry);
+	buf->total = buf->number * buf->size;
+
+	return (glibtop_open_files_entry*)g_array_free(entries, FALSE);
+}
diff -Nrup sysdeps/solaris/proctime.c sysdeps/solaris/proctime.c
--- sysdeps/solaris/proctime.c	2005-12-12 18:09:40.000000000 +0800
+++ sysdeps/solaris/proctime.c	2006-07-31 21:43:05.428937000 +0800
@@ -45,6 +45,11 @@ void
 glibtop_get_proc_time_s (glibtop *server, glibtop_proc_time *buf,
 			 pid_t pid)
 {
+#ifdef HAVE_PROCFS_H
+	struct psinfo pinfo;
+#else
+	struct prpsinfo pinfo;
+#endif
 	struct prusage prusage;
 
 	memset (buf, 0, sizeof (glibtop_proc_time));
@@ -53,17 +58,18 @@ glibtop_get_proc_time_s (glibtop *server
 
 	if(pid)
 	{
+		if (glibtop_get_proc_data_psinfo_s(server, &pinfo, pid))
+			return;
+		buf->start_time = pinfo.pr_start.tv_sec;
+		
 		if (glibtop_get_proc_data_usage_s (server, &prusage, pid))
 			return;
 
-		buf->start_time = prusage.pr_create.tv_sec;
-
-		buf->rtime = prusage.pr_rtime.tv_sec * 1E+6 +
-			prusage.pr_rtime.tv_nsec / 1E+3;
 		buf->utime = prusage.pr_utime.tv_sec * 1E+6 +
 			prusage.pr_utime.tv_nsec / 1E+3;
 		buf->stime = prusage.pr_stime.tv_sec * 1E+6 +
 			prusage.pr_stime.tv_nsec / 1E+3;
+		buf->rtime = (buf->utime + buf->stime) / 10000;
 	}
 
 	buf->flags = _glibtop_sysdeps_proc_time;
diff -Nrup sysdeps/solaris/sem_limits.c sysdeps/solaris/sem_limits.c
--- sysdeps/solaris/sem_limits.c	2005-12-12 18:09:40.000000000 +0800
+++ sysdeps/solaris/sem_limits.c	2006-07-30 20:19:48.877154000 +0800
@@ -26,11 +26,13 @@
 #include <glibtop/sem_limits.h>
 
 #include <kvm.h>
+#include <rctl.h>
 #include <sys/sem.h>
 
-static const struct nlist nlst[] = { {"seminfo"}, {NULL} };
+static const struct nlist nlst[] = { {"glibtop_sem_limits"}, {NULL} };
+#if GLIBTOP_SOLARIS_RELEASE < 51000
 static const unsigned long _glibtop_sysdeps_sem_limits =
-#if GLIBTOP_SOLARIS_RELEASE <= 570
+#if GLIBTOP_SOLARIS_RELEASE <= 50700
 (1L << GLIBTOP_IPC_SEMMAP) +
 #endif
 (1L << GLIBTOP_IPC_SEMMNI) + (1L << GLIBTOP_IPC_SEMMNS) +
@@ -38,37 +40,60 @@ static const unsigned long _glibtop_sysd
 (1L << GLIBTOP_IPC_SEMOPM) + (1L << GLIBTOP_IPC_SEMUME) +
 (1L << GLIBTOP_IPC_SEMUSZ) + (1L << GLIBTOP_IPC_SEMVMX) +
 (1L << GLIBTOP_IPC_SEMAEM);
+#else
+/*static const unsigned long _glibtop_sysdeps_sem_limits = 0;*/
+static const unsigned long _glibtop_sysdeps_sem_limits =
+(1L << GLIBTOP_IPC_SEMMNI) +
+(1L << GLIBTOP_IPC_SEMMSL) +
+(1L << GLIBTOP_IPC_SEMOPM);
+#endif
+
 
 /* Init function. */
 
+#if GLIBTOP_SUID_SEM_LIMITS
 void
 glibtop_init_sem_limits_p (glibtop *server)
+#else
+void
+glibtop_init_sem_limits_s (glibtop *server)
+#endif 
 {
+#if GLIBTOP_SOLARIS_RELEASE < 51000
+
    	kvm_t *kd = server->machine.kd;
 
 	if(kd && !kvm_nlist(kd, nlst))
 		server->sysdeps.sem_limits = _glibtop_sysdeps_sem_limits;
 	else
 	   	server->sysdeps.sem_limits = 0;
+#endif
 }
 
 /* Provides information about sysv sem limits. */
 
+#if GLIBTOP_SUID_SEM_LIMITS
 void
 glibtop_get_sem_limits_p (glibtop *server, glibtop_sem_limits *buf)
+#else
+void
+glibtop_get_sem_limits_s (glibtop *server, glibtop_sem_limits *buf)
+#endif 
 {
+#if GLIBTOP_SOLARIS_RELEASE < 51000
    	kvm_t *kd = server->machine.kd;
-	struct seminfo sinfo;
+        glibtop_sem_limits sinfo;
 
 	memset (buf, 0, sizeof (glibtop_sem_limits));
 
 	if(!(server->sysdeps.sem_limits))
 	   	return;
 	if(kvm_read(kd, nlst[0].n_value, (void *)&sinfo,
-		    sizeof(struct seminfo)) != sizeof(struct seminfo))
+                    sizeof(glibtop_sem_limits)) != sizeof(glibtop_sem_limits))
+
 	   	return;
 
-#if GLIBTOP_SOLARIS_RELEASE <= 570
+#if GLIBTOP_SOLARIS_RELEASE <= 50700
 	/* This field don't exist anymore in Solaris 8.
 	 * Thanks to Laszlo PETER <Laszlo.Peter@ireland.sun.com>. */
 	buf->semmap = sinfo.semmap;
@@ -82,5 +107,30 @@ glibtop_get_sem_limits_p (glibtop *serve
 	buf->semusz = sinfo.semusz;
 	buf->semvmx = sinfo.semvmx;
 	buf->semaem = sinfo.semaem;
-	buf->flags = _glibtop_sysdeps_sem_limits;
+#endif
+
+#if GLIBTOP_SOLARIS_RELEASE >= 51000
+       rctlblk_t *rblk;
+       if ((rblk = malloc(rctlblk_size())) == NULL)
+               return;
+
+       if (getrctl("process.max-sem-ops", NULL, rblk, RCTL_FIRST) == -1)
+               return;
+       else
+               buf->semopm = rctlblk_get_value(rblk);
+
+       if (getrctl("process.max-sem-nsems", NULL, rblk, RCTL_FIRST) == -1)
+               return;
+       else
+               buf->semmsl = rctlblk_get_value(rblk);
+
+       if (getrctl("project.max-sem-ids", NULL, rblk, RCTL_FIRST) == -1)
+               return;
+       else
+               buf->semmni = rctlblk_get_value(rblk);
+	/* there are only 3 fields, the other ones have been obsoleted in S10 and Nevada
+	 and no longer have system-wide limits */
+#endif
+       buf->flags = _glibtop_sysdeps_sem_limits;
+
 }
diff -Nrup sysdeps/solaris/shm_limits.c sysdeps/solaris/shm_limits.c
--- sysdeps/solaris/shm_limits.c	2005-12-12 18:09:40.000000000 +0800
+++ sysdeps/solaris/shm_limits.c	2006-07-30 20:20:36.363728000 +0800
@@ -26,40 +26,64 @@
 #include <glibtop/shm_limits.h>
 
 #include <kvm.h>
+#include <rctl.h>
 #include <sys/shm.h>
 
-static const struct nlist nlst[] = { {"shminfo"}, {NULL} };
+static const struct nlist nlst[] = { {"glibtop_shm_limits"}, {NULL} };
 
-#if GLIBTOP_SOLARIS_RELEASE < 590
+#if GLIBTOP_SOLARIS_RELEASE >=51000
+/*static const unsigned long _glibtop_sysdeps_shm_limits = 0;*/
+static const unsigned long _glibtop_sysdeps_shm_limits = 
+(1L << GLIBTOP_IPC_SHMMAX) + 
+(1L << GLIBTOP_IPC_SHMMIN);
+#else
+# if GLIBTOP_SOLARIS_RELEASE < 50900
 static const unsigned long _glibtop_sysdeps_shm_limits =
 (1L << GLIBTOP_IPC_SHMMAX) + (1L << GLIBTOP_IPC_SHMMIN);
 
-#else
+# else
 static const unsigned long _glibtop_sysdeps_shm_limits =
 (1L << GLIBTOP_IPC_SHMMAX) + (1L << GLIBTOP_IPC_SHMMIN) +
 (1L << GLIBTOP_IPC_SHMMNI) + (1L << GLIBTOP_IPC_SHMSEG);
+# endif
 #endif
 
 /* Init function. */
 
+#if GLIBTOP_SUID_SHM_LIMITS
 void
 glibtop_init_shm_limits_p (glibtop *server)
+#else
+void
+glibtop_init_shm_limits_s (glibtop *server)
+#endif 
 {
+#if GLIBTOP_SOLARIS_RELEASE < 51000
+
 	kvm_t * const kd = server->machine.kd;
 
 	if(kd && !kvm_nlist(kd, nlst))
 		server->sysdeps.shm_limits = _glibtop_sysdeps_shm_limits;
 	else
 		server->sysdeps.shm_limits = 0;
+#endif
 }
 
 /* Provides information about sysv ipc limits. */
 
+#if GLIBTOP_SUID_SHM_LIMITS
 void
 glibtop_get_shm_limits_p (glibtop *server, glibtop_shm_limits *buf)
+#else
+void
+glibtop_get_shm_limits_s (glibtop *server, glibtop_shm_limits *buf)
+#endif 
 {
+#if GLIBTOP_SOLARIS_RELEASE < 51000
+
 	kvm_t * const kd = server->machine.kd;
-	struct shminfo sinfo;
+        glibtop_shm_limits sinfo;
+
 
 	memset (buf, 0, sizeof (glibtop_shm_limits));
 
@@ -67,14 +91,32 @@ glibtop_get_shm_limits_p (glibtop *serve
 		return;
 
 	if(kvm_read(kd, nlst[0].n_value, (void *)&sinfo,
-		    sizeof(struct shminfo)) != sizeof(struct shminfo))
+                    sizeof(glibtop_shm_limits)) != sizeof(glibtop_shm_limits))
+
 		return;
 
 	buf->shmmax = sinfo.shmmax;
 	buf->shmmni = sinfo.shmmni;
-#if GLIBTOP_SOLARIS_RELEASE < 590
+#if GLIBTOP_SOLARIS_RELEASE < 50900
 	buf->shmmin = sinfo.shmmin;
 	buf->shmseg = sinfo.shmseg;
+# endif
+#endif
+#if GLIBTOP_SOLARIS_RELEASE >= 51000
+       rctlblk_t *rblk;
+       if ((rblk = malloc(rctlblk_size())) == NULL)
+               return;
+
+       if (getrctl("project.max-shm-memory", NULL, rblk, RCTL_FIRST) == -1)
+               return;
+       else
+              buf->shmmax = rctlblk_get_value(rblk);
+
+       if (getrctl("project.max-shm-ids", NULL, rblk, RCTL_FIRST) == -1)
+               return;
+       else
+               buf->shmmni = rctlblk_get_value(rblk);
+
 #endif
 	buf->flags = _glibtop_sysdeps_shm_limits;
 }
diff -Nrup sysdeps/solaris/siglist.c sysdeps/solaris/siglist.c
--- sysdeps/solaris/siglist.c	2005-12-12 18:09:40.000000000 +0800
+++ sysdeps/solaris/siglist.c	2006-07-27 17:55:24.920014000 +0800
@@ -63,6 +63,7 @@ const glibtop_signame glibtop_sys_siglis
    { 35, "SIGTHAW", "Checkpoint Thaw" },
    { 36, "SIGCANCEL","Thread Cancelation" },
    { 37, "SIGLOST", "Resource Lost" },
+#if GLIBTOP_SOLARIS_RELEASE < 50900    /* S8 */
    { 38, "SIGRTMIN","First Realtime Signal" },
    { 39, "SIGRTMIN+1", "Second Realtime Signal" },
    { 40, "SIGRTMIN+2", "Third Realtime Signal" },
@@ -71,5 +72,30 @@ const glibtop_signame glibtop_sys_siglis
    { 43, "SIGRTMAX-2", "Third Last Realtime Signal" },
    { 44, "SIGRTMAX-1", "Second Last Realtime Signal" },
    { 45, "SIGRTMAX", "Last Realtime Signal" },
+#endif
+#if GLIBTOP_SOLARIS_RELEASE >= 50900
+   { 38, "SIGXRES","Resource Control Exceeded" },
+#if GLIBTOP_SOLARIS_RELEASE <51000	/* signal here existed in s9 */
+   { 39, "SIGRTMIN","First Realtime Signal" },
+   { 40, "SIGRTMIN+1", "Second Realtime Signal" },
+   { 41, "SIGRTMIN+2", "Third Realtime Signal" },
+   { 42, "SIGRTMIN+3", "Fourth Realtime Signal" },
+   { 43, "SIGRTMAX-3", "Fourth Last Realtime Signal" },
+   { 44, "SIGRTMAX-2", "Third Last Realtime Signal" },
+   { 45, "SIGRTMAX-1", "Second Last Realtime Signal" },
+   { 46, "SIGRTMAX", "Last Realtime Signal" },
+#else /*  signal here existed in s10 and s11 */
+   { 39, "SIGJVM1","Reserved signal for Java Virtual Machine" },
+   { 40, "SIGJVM1","Reserved signal for Java Virtual Machine" },
+   { 41, "SIGRTMIN","First Realtime Signal" },
+   { 42, "SIGRTMIN+1", "Second Realtime Signal" },
+   { 43, "SIGRTMIN+2", "Third Realtime Signal" },
+   { 44, "SIGRTMIN+3", "Fourth Realtime Signal" },
+   { 45, "SIGRTMAX-3", "Fourth Last Realtime Signal" },
+   { 46, "SIGRTMAX-2", "Third Last Realtime Signal" },
+   { 47, "SIGRTMAX-1", "Second Last Realtime Signal" },
+   { 48, "SIGRTMAX", "Last Realtime Signal" },
+#endif
+#endif
    {  0, NULL, NULL }
 };
diff -Nrup sysdeps/solaris/sysinfo.c sysdeps/solaris/sysinfo.c
--- sysdeps/solaris/sysinfo.c	1970-01-01 08:00:00.000000000 +0800
+++ sysdeps/solaris/sysinfo.c	2006-07-03 10:50:14.165481000 +0800
@@ -0,0 +1,48 @@
+/* $Id: sysinfo.c,v 1.22 2004/11/28 01:32:55 bdejean Exp $ */
+
+/* Copyright (C) 1998-99 Martin Baulig
+   This file is part of LibGTop 1.0.
+
+   Contributed by Martin Baulig <martin@home-of-linux.org>, April 1998.
+
+   LibGTop is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License,
+   or (at your option) any later version.
+
+   LibGTop is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+   for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with LibGTop; see the file COPYING. If not, write to the
+   Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+
+#include <config.h>
+#include <glibtop/error.h>
+#include <glibtop/cpu.h>
+#include <glibtop/sysinfo.h>
+
+#include "glibtop_private.h"
+
+
+static const unsigned long _glibtop_sysdeps_sysinfo =
+(1L << GLIBTOP_SYSINFO_CPUINFO);
+
+static glibtop_sysinfo sysinfo = { .flags = 0 };
+
+static void
+init_sysinfo (glibtop *server)
+{
+
+}
+
+const glibtop_sysinfo *
+glibtop_get_sysinfo_s (glibtop *server)
+{
+	init_sysinfo (server);
+	return &sysinfo;
+}
